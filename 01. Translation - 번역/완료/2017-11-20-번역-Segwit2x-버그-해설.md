---
layout: translation
category: translation

author: Kcalvin
authorid: kcalvin
tag: kcalvin
title: "Segwit2x 버그 해설"
date: 2017-11-20
excerpt: "한 주 전에 하드포크를 취소하지 않았더라면 결과가 어떻게 되었을지에 대한 세부내용을 검토해보고자 합니다."
ori_author: Jimmy Song
ori_title: "Segwit2x Bugs Explained"
ori_address: https://bitcointechtalk.com/segwit2x-bugs-explained-8e0c286124bc
comments: true
---

Segwit2x 하드포크는 불과 1주 여 전에 2x 메일링 리스트에 보내진 한 메일에서 취소되었습니다 . 몇몇 단체들은 무조건 네트워크를 분리하겠다고 엄포를 놓았고, 우리 모두 혹시 누군가 2x 하드포크를 채굴할지 여부를 보기 위해 494784번째 블록을 목 빠지게 기다렸습니다.

그러나 알고 보니 Segwit2x 소프트웨어에 버그가 있었고, 해당 버그는 494,782번째 블록에서 소프트웨어 클라이언트를 멈추게 하였습니다. 본문에서는 소프트웨어를 멈추게 한 원인이 무엇인지, 또한 왜 하드포크가 일어나기로 계획된 블록 한 개 전에 멈추게 된 것인지, 만약 Belshe 외 주동자들이, 한 주 전에 하드포크를 취소하지 않았더라면 결과가 어떻게 되었을지에 대한 세부내용을 검토해보고자 합니다.

### 설정
하드포크의 2x는 지난 6개월 동안 계획되어 왔습니다. 뉴욕 협정은 5월 말에 이루어졌고, 해당 코드의 대부분은 6월경에 완료되었으며 btc1/Segwit2x 소프트웨어는 7월에 공개되었습니다.

NYA 세부사항 :

1. Segwit은 95%가 아닌 80%에서 활성화
2. 2x 하드포크는 6개월 이내(5월23일)에 작동

해당 소프트웨어는 개발 책임자였던 Jeff Garzik에 의해 btc1 저장소에 생성되었습니다. 첫 번째 조건을 충족시키기 위해 James Hilliard의 BIP91 제안을 구현했고, 이를 통해 8월 24일 네트워크 상의 481,824번째 블록에서 Segwit을 성공적으로 작동시킬 수 있었습니다.

두 번째 조건을 충족하기 위해, btc1 소프트웨어는 Segwit이 적용된 이래 정확히 144*90번째 블록 이후 블록 사이즈를 두 배로 늘리는 하드포크가 작동하도록 하는 조항을 추가했습니다. 이 숫자가 도출된 이유를 설명하자면 10분에 한 블록은 곧 하루에 144개 블록을 의미하며, 144*90번째 블록을 생성하기 위해서는 대략 90일이 소요되기 때문입니다. 이것으로 포크는 494,784번째 블록으로 지정되었으며 대략 11월 15일에 실제 포크가 일어나도록 하여, NYA의 두 번째 조항을 만족시키게 되었습니다.

### 버그

비트코인 코어와 btc1 코드 베이스의 차이는 그리 크지 않았습니다. 코드 변경은 총약 500줄 가량이었으나, 대부분은 컨센서스 자체에 영향을 미치는 것은 아니었습니다. 그러나 494,784번째 블록에서 하드포크를 지원하기 위한 100여 줄의 코드에서는 적어도 2개의 버그가 발생했습니다.

해당 버그를 이해하기 위한 가장 쉬운 방법은 144*90번째 블록 이후 포크를 작동시키자고 제안되었던 일련의 변경 사항을 확인하는 것입니다.

![](/asset/img/post/seg2-1.jpg)

![](/asset/img/post/seg2-2.jpg)

Segwit 작동 이후 블록 크기가 2배가 되기까지 걸리는 시간을 설정하는 매개변수가 있고 이는 정확히 144*90번째 블록입니다. 본 코드에서 이는 "Segwit seasoning"이라는 개념으로 불립니다. 이는 144*90번째 블록 전까지 블록 크기를 2배로 늘릴 필요 없이 Segwit만 존재하는 것을 가능케 합니다.

더 큰 블록을 받아들여야 하는 때인지 아닌지를 판별하기 위해서는 144*90번째 블록 이후 fSegwitSeasoned라 하는 boolean 변수가 참으로 설정되어야 하며, 그 이전까지는 거짓입니다. 이후의 if 문은 이 boolean을 사용하여 최대 기본 블록 크기 (블록 크기에서 witness data를 차감한 값)의 값이 무엇인지를 정합니다 (참이라면 2mb, 거짓이라면 1mb). 통상적으로 블록 크기가 1mb를 초과하는 기본블록(witness data를 포함하지 않은 블록을 의미함)은 거부되지만, 여기에서 우리는 fSegwitSeasoned가 참일 때 2mb를 초과하는 경우에만 거부된다는 것을 알 수 있습니다. 이것은 지나치게 큰 블록을 거부하는 합의 코드의 핵심이며, 따라서 하드포크가 필요한 부분입니다.

fSegwitSeasoned가 참 혹은 거짓인지 알아보기 위해 해당 코드는 VersionBitsState 함수를 사용합니다. 구체적으로는 코드가 현재 블록에서부터 144*90번째 이전의 블록을 확인하여 Segwit이 네트워크에서 활성화되어 있는지 확인합니다. 만약 144*90 이전의 블록에서 Segwit이 활성화되어 있었다면, >1MB 기본 블록들은 해당 블록에서 합법적이라는 의미이고, 해당 코드는 바로 이를 시험하기 위함입니다.

### VersionBitsState
여기에는 찾기 힘든 버그가 존재하는데 VersionBitsState를 불러오는 방식과 연관이 있습니다. 이를 이해하기 위해 versionbits.cpp에서 정의된 함수를 살펴보도록 하겠습니다.

![](/asset/img/post/seg2-3.jpg)

코드 베이스에 대한 기본적인 이해가 선행되지 않고서는 본 글의 의미를 완벽히 소화하기 쉽지 않을 수 있기에, 설명을 참고해주시기 바랍니다. VersionBiteState 함수의 첫 번째 인수는 블록에 대한 포인터가 되어야 합니다. pindexPrev 변수는 블록 자체가 아니라 해당 블록의 이전 블록(부모 블록)에 대한 포인터라는 점을 나타내게 됩니다. 실제로 바로 이러한 이유로 인해 validation.cpp 파일에 있는 다른 모든 VersionBitsState 호출은 블록 그 자체가 아닌 해당 블록의 부모 블록에게 포인터를 사용하게 됩니다.

그리고 여기서 문제가 있습니다: 위의 pindexForkBuffer은 현재 블록의 부모 블록이 아닌 현재블록에서 144*90개로 설정되어 있습니다. 요컨대, 우리는 현재 블록의 144*90-1개 이전의 블록에서 Segwit이 활성화 되었는지를 여부를 확인하는 것입니다. 우리는 한 블록 벗어나버렸고 그러므로 큰 블록들은 한 블록 일찍 활성화됩니다.

### 어떻게 발각되지 않았을까?
이러한 변경은 더 큰 pull request의 일부였습니다(pull request의 링크). 이 pull request는 221개의 코멘트가 있었는데, 대부분 2MB 블록의 정의에 대한 토론이었습니다. 이 특정 커밋은 페이지 아주 밑에 가서야 pull request에 포함되고 단 한 사람(opetruzel)만이 변경을 승인한 것으로 보입니다. 끝으로 가면 (비트코인 캐시로 유명한) deadalnix가 이 pull request가 충분한 테스트를 거치지 않았다는 점에 대한 불만을 제기 한 모습이 보입니다.

### 오류의 오류
과거의 144*90번째 블록을 계산하는 코드는 올바른 방법으로 받아들여졌었고 차후 이와 관련하여 문제가 발생될 것이라고는 그 누구도 예상하지 못했습니다.

2x 하드포크가 1x 체인에 의해 추월당하고 재구성되지 않기 위해 (제거되지 않기 위해), 새로이 전멸 보호 규정(wipeout protection)이 도입되었습니다. 해당 규정은 포크가 일어나는 기본 블록의 사이즈가 1MB보다 클 것을 집행하고 있습니다. 이로 인해 494,784번째 블록이 아닌 494,783번째 블록이 >1MB인 기본 블록 사이즈를 갖도록 강제하게 되었는데, 이는 위와 같은 논리가 적용된 예라 할 수 있습니다.

이것은 btc1이 494,782번째 블록에서 멈추게 된 이유입니다. btc1 소프트웨어는 1MB보다 큰 기본 블록을 494,783번째 블록에서 기다리고 있기 때문입니다.

### 더 설명할 것들
마치 이 Off-by-one 버그만으로는 충분하지 않았던 듯, 또 다른 버그가 BlockAssembler code에서 발견되었습니다. BlockAssembler는 miner.cpp의 일부인데, 새로운 블록 생성을 담당하는 코드입니다. 일반적으로 이 코드는 블록을 생성하는 채굴자들에게만 유용한 코드입니다.

그중에서도 특히 변수 fWitnessSeasoned는 초기화되지 않은 채 사용됩니다. 이는 Pieter Wuille가 보여줬듯이 미정의 행동입니다.

![](/asset/img/post/seg2-4.jpg)

![](/asset/img/post/seg2-5.jpg)

왜 이것이 중요할까요? 글쎄, 알고 보니 이 특정 변수는 소프트웨어가 만들 수 있는 최대 블록 크기와 블록 무게를 결정합니다. 이 변수가 거짓이라면 소프트웨어는 2x 하드포크의 사양에 따른 최대 블록 무게가 8,000,000이 아닌 4,000,000이 되므로 체인을 포크 할 수 있을 만큼 큰 블록을 절대 만들지 못합니다. 반대로 이 변수가 참이면 소프트웨어는 체인의 포크 전에 무효한 블록을 생성합니다. 따라서 채굴자가 2x를 채굴하고 싶어도 소프트웨어가 허용하지 않게 됩니다!

이 코드 변경은 Jeff Garzik에 의하여 pull request에 도입되었고 해당 코드의 변경사항에 대한 검토에는 단 한명(Faysal M)이 참여하였고 그는 버그를 찾지 못하였습니다.

### 2x가 취소되지 않았다면 어떤 일이 일어났을까?
2x 포크를 계획하던 채굴자들은 Jeff Garzik과 segwit2x 팀이 여러 번 그렇게 선언했기 때문에 자연스럽게 494784번 블록이 포크가 일어나는 블록이라 생각했을 것입니다.

채굴자들은 더 큰 블록을 만드는 것을 막을 수 있는 위의 코드를 사용하지 않았어도, 494,783번째 블록이 아닌 484,784번째 블록부터 더 큰 블록을 만들 수 있도록 소프트웨어를 맞춤형 화했을 것입니다. 이는 494,782번째 블록에서 똑같이 멈추게 되었을 것이고 네트워크 상의 참여자들은 문제의 원인을 찾기 위해 디버깅을 시작하였을 것입니다.

가장 그럴듯한 시나리오는, 어떤 채굴자들이 상황을 파악하고는 2x를 포크시키기 위해 그냥 큰 블록을 채굴하게 되는 것입니다. 그게 얼마나 오래 걸렸을지는 아무도 알 수 없지만, 분명한 것은 PR 재앙이었을 것이라는 점입니다.

게다가 Greg Maxwell이 이곳에서 지적했듯이, 블록 494783이 아닌 494784에서 거래소들이 계좌를 동결했을 것이며 이로 인해 2x 코인의 모든 잔고는 494783번째 블록에 누가 거래를 성사시켰는지에 결정될 것입니다. 이는 또다시 심각한 손해를 끼쳤을 것입니다.

### 결론
합의 변경사항을 검토하고 테스트하는 것은 정말 어렵습니다. btc1은 이러한 합의 변경사항에 정확히 1명의 코더와 1명의 리뷰어만 있었던 것으로 보이며, 이는 첫 번째와 같은 미묘한 버그, 또는 두 번째와 같은 명백한 버그를 감지하기에는 충분하지 않습니다. 더구나, off-by-one 변경이 비교적 빠른 날짜 (~6월 15일)에 승인되었기 때문에 나중에 코드가 전멸 보호 규정으로 사용됐을 때, 코드는 이전의 "리뷰"가 있었기 때문에 양호한 것으로 간주하였습니다.

여러 리뷰들 사이에서 단 하나의 나쁜 리뷰는 블록체인 네트워크 상의 합의 시스템 전체를 치명적인 버그로 와해시킬 수도 있습니다.

이로 인해 중대한 변경 사항이 철저하게 검토되는 교훈적인 실사례가 될 수 있기를 바랍니다. 단순히 코딩에서뿐만 아니라 철저한 검토 과정을 거치는 개발자들에게 경의를 표합니다.

